\documentclass{article}

\usepackage[dvipsnames]{xcolor} % Code highlighting color
\usepackage[catalan]{babel} % Language 
\usepackage{indentfirst}
\usepackage{fontspec} 
\usepackage{fullpage}
\usepackage[a4paper, margin=2cm]{geometry} % To change the margins
\usepackage{graphicx} % Insert images
\usepackage[hidelinks]{hyperref} % Links color
\usepackage[final]{pdfpages}
\usepackage{ragged2e}
\usepackage{wrapfig} %To Text wrap
\usepackage{listings} % Add code
\usepackage{verbatim}
\usepackage{nameref}
\usepackage{tikz}
\usepackage{subcaption}
\usepackage{multirow}
\usepackage{colortbl}

\setlength{\parskip}{0.7em}
\setlength{\parindent}{0cm}
\linespread{1.2}


\title{
	\Huge
	\textbf{SuperSopa} \\ 
	\scshape Algorísmia
}
\author{
	Marc Asenjo i Ponce de León \and 
	Joan Marcè i Igual
}
\date{\today}

\begin{document}
\maketitle


\section{Introducció}
En aquest treball es demana realitzar un programa que solucioni el problema de la \emph{Super Sopa}. Aquest s'assembla força a la sopa de lletres però amb la diferència que es les paraules no han d'estar necessàriament en una fila (vertical, horitzontal o diagonal) sinó que cada lletra de la paraula pot estar a una de les 8 lletres adjacents a aquesta. Així doncs la possibilitat de camins és força gran i és força útil tenir un programa per solucionar aquest problema.

Així doncs es defineixen els següents termes:

\begin{itemize}
	\item \verb|n| Amplada del tauler
	\item \verb|m| Alçada del tauler
	\item \verb|l| Llargada de la paraula més llarga
	\item \verb|k| Nombre de paraules
\end{itemize}

\section{Diccionaris}
S'han plantejat diferent maneres de crear un diccionari per així poder comprovar si una sèrie de caràcters contenen una paraula de les que s'han de buscar. Així doncs, s'ha creat una \verb|interface| \verb|Diccionari| que permet fer diferents implementacions, conté les següents funcions:

\begin{itemize}
	\item \verb|void insertElement(const string&)| Afegir un element.
	\item \verb|bool contains(const string&)| Comprovar si un string està al diccionari.
	\item \verb|void reset()| Reiniciar la cerca.
	\item \verb|pair<bool,bool> stepForwards(char c)| Avançar un pas a la cerca amb el caràcter \verb|c| i comprovar si hi ha un prefix o una paraula que contingui la cerca actual.
	\item \verb|void stepBackWards()| Tirar enrere un pas la cerca actual.
	\item \verb|string popWord()| Obtenir la paraula de la cerca actual i eliminar-la del diccionari.
	\item \verb|bool isEmpty()| Comprovar si el diccionari està buit.
\end{itemize}
	
\subsection{\texttt{TreeDictionary}}
Aquest diccionari emmagatzema la informació en forma d'un arbre. Cada node té les seves pròpies dades i una taula de hash que relaciona un caràcter amb un punter a un altre node. D'aquesta manera al anar buscant només cal anar baixant per l'arbre per trobar si una paraula es troba al diccionari. Els costos de realitzar les operacions són els següents:

\begin{itemize}
	\item \verb|void insertElement(const string&)| $\theta(l)$
	\item \verb|pair<bool,bool> stepForwards(char c)| $\theta(1)$
	\item \verb|void stepBackWards()| $\theta(1)$
	\item \verb|string popWord()| $\theta(l)$
	\item \verb|bool isEmpty()| $\theta(1)$
\end{itemize}

\subsection{\texttt{HashDictionary}}
Aquest diccionari es basa en el fàcil i ràpid accés a les paraules, tant per consultar-les com per eliminar-les. Utilitza dues taules de hash: la primera per les paraules del diccionari, i la segona per emmagatzemar els resultats de la funció "stepForwards" que ja s'han calculat, per tal d'evitar càlculs innecessaris. Aquí tenim els costos:

\begin{itemize}
	\item \verb|void insertElement(const string&)| $\theta(1)$
	\item \verb|pair<bool,bool> stepForwards(char c)| $\theta(1 | k·l)$ aquest valor depèn de si l'element buscat estava en el map d'elements ja buscats o no.
	\item \verb|void stepBackWards()| $\theta(1)$
	\item \verb|string popWord()| $\theta(1)$
	\item \verb|bool isEmpty()| $\theta(1)$
\end{itemize}

\subsection{\texttt{LinearDictionary}}
Molt similar al HashDictionary, només que utilitza un vector ordenat per tal de guardar les paraules del diccionari. També utilitza el hash per no repetir càlculs. Els costos d'accés poden ser o lineals o, aprofitant l'ordenació, logarítimics:

\begin{itemize}
	\item \verb|void insertElement(const string&)| $\theta(log k)$
	\item \verb|pair<bool,bool> stepForwards(char c)| $\theta(1 | k·l)$ aquest valor depèn de si l'element buscat estava en el map d'elements ja buscats o no.
	\item \verb|void stepBackWards()| $\theta(1)$
	\item \verb|string popWord()| $\theta(log k)$
	\item \verb|bool isEmpty()| $\theta(1)$
\end{itemize}

\section{Algoritmes de solucionat}

Per als algoritmes de solucionat s'ha creat una \verb|interface| \verb|Solver| que han d'implementar totes les classes que es facin per solucionar el problema, d'aquesta manera es poden utilitzar diferents algoritmes sense haver de reescriure el codi. Les funcions bàsiques d'aquesta són:

\begin{itemize}
	\item \verb|setDictionary(Dictionary*)| Per afegir un diccionari al solucionador.
	\item \verb|setWords(vector<string>&)| Per afegir les paraules que s'han de buscar.
	\item \verb|setBoard(Board &)| Per afegir el tauler on buscar les paraules.
	\item \verb|solve()| Es crida aquesta funció quan es vol solucionar el tauler.
	\item \verb|printSolution()| Per imprimir la solució un cop s'ha calculat.
\end{itemize}

Les dues classes que han heretat d'aquesta \verb|interface| han estat \verb|PatronSolver| que busca si un patró de ce\l.les del tauler té una paraula i \verb|WordSolver| que busca si una determinada paraula es troba al tauler.

\subsection{\texttt{PatronSolver}}
Aquest algoritme busca si una paraula es troba en un en una sèrie de ce\l.les del tauler. Per fer-ho utilitza un diccionari i per cada ce\l.la comprova si conté una paraula del diccionari. El cost d'aquest algoritme és el següent:

\[ k·insercio + n·m·8^l·l·(stepForward + stepBackwards + isEmpty) + k·popWord \]

On $insercio$ és el cost d'inserir un element al diccionari, $stepForward$ és el cos d'avançar un pas al diccionari $stepBackwards$ és el cost de tirar un pas enrere al diccionari, $isEmpty$ és el cost de saber si el diccionari està buit i $popWord$ és el
cost de d'eliminar una paraula del diccionari.

\subsection{\texttt{WordSolver}}

Amb aquest solucionador assolim l'objectiu d'examinar la possibilitat que una paraula concreta del diccionari sigui al tauler.
La forma en què funciona exactament és a base de diferents DFS molt restringits. Bàsicament, per cada paraula fa un DFS començant per cada posició diferent del tauler.
Aquest DFS es crida recursivament en les màxim 8 posicions contigües a la casella actual, podent fer repeticions, però només ho fa si el caràcter (o número) que es troba en la casella actual correspon al que estem observant de la paraula que busquem.
Per tant, quan un DFS comença, es comprova que el caràcter a la casella sigui igual al primer de l'string, i si es compleix es crida recursivament a 8 (o menys) DFS indicant que s'han de comparar ara amb el segon caràcter de l'string.

El cost d'aquest algoritme seria de $\theta(k·n·m·8^l·l)$ si considerem que es fan tots els DFS possibles de "l" de llargada, però com hem vist l'algoritme només segueix un camí un de cada 10 cops si considerem que els números del tauler són aleatoris.
Per tant, podem aproximar el cost real a $\theta(k·n·m·l)$.

\section{Compilació i execució}

Per compilar el codi cal anar a la carpeta \verb|Code| i executar la comanda \verb|make| es generarà una carpeta \verb|build| on hi haurà l'executable \verb|SuperSopa.exe|. És necessari tenir un compilador que suporti \verb|c++11| sinó el codi no compilarà.

Per executar les diferents versions dels diccionaris i dels programes per solucionar només cal executar \verb|./SuperSopa.exe| i ja apareixerà un menú per escollir les diferents opcions. 

\begin{lstlisting}[frame=single]
	What do you want to do?
	0) Exit
	1) Generate words file
	2) Generate board file
	3) Call solver
\end{lstlisting}

El programa primer necessita que se li generi un arxiu de paraules i un arxiu de tauler, disposa d'aquesta funcionalitat. Per generar aquests arxius escollir les opcions \verb|1| i \verb|2|.

\section{Tests}

S'han fet diversos tests per cada algoritme en funció de \verb|n| (tamany del tauler quadrat), \verb|k| (nombre de paraules del diccionari) i \verb|l| (longitud màxima de les paraules).

\subsection{\texttt{PatronSearch} amb \texttt{TreeDictionary}}

Amb \verb|l = 30|

\begin{tabular}{cl||c|c|c}
	\multicolumn{2}{c}{ } & \multicolumn{3}{c}{k} \\
	 & & 1000 & 2000 & 10000 \\
	\cline{2-5}
	\multirow{3}{*}{n} 
	& 100 & 0.21 & 0.5 & 2.02 \\
	& 200 & 0.34 & 0.85 & 5.51 \\
	& 2000 & 0.5 & 0 & 16.1 \\
\end{tabular}

\end{document}